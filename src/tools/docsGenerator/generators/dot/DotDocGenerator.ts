import {
    ImportsBetweenPackagesRuleConfig, PackageFolder, PackageSubFolder
} from "../../../../model/ImportsBetweenPackagesRuleConfig";
import { DocConfig } from "../../Config";
import { Edge } from "../../graph/Edge";
import { GraphCluster } from "../../graph/GraphCluster";
import { GraphGenerator } from "../../graph/GraphGenerator";
import { GraphNode } from "../../graph/GraphNode";
import { GraphVisitor } from "../../graph/utils/GraphWalker";
import { IDocGenerator } from "../../interfaces/IDocGenerator";
import { IDocOutputter } from "../../interfaces/IDocOutputter";
import { DateHelper } from "../../utils/DateHelper";
import { DocGeneratorBase } from "../shared/DocGeneratorBase";
import { DotStyleGenerator } from "./utils/DotStyleGenerator";
import { MapNameToId } from "./utils/MapNameToId";

export class DotDocGenerator extends DocGeneratorBase implements IDocGenerator {
  private containerId = 1;
  private mapNameToId = new MapNameToId();
  private styler: DotStyleGenerator;

  constructor(protected config: DocConfig, protected outputter: IDocOutputter) {
    super(config, outputter);

    this.styler = new DotStyleGenerator(config, outputter);
  }

  generateDoc(packageConfig: ImportsBetweenPackagesRuleConfig): void {
    const generator = new GraphGenerator(this.config);
    const root = generator.generateGraph(packageConfig);

    this.outputSectionSeparator("Header");
    this.outputHeader();
    this.outputter.outputLine(``);

    this.outputSectionSeparator("Styling");
    this.styler.outputStyling();
    this.outputter.outputLine(``);

    this.outputSectionSeparator("Nodes");
    this.outputTopLevelNodes(
      root.nodes.filter(node => !(node instanceof GraphCluster))
    );
    this.outputter.outputLine(``);

    if (!this.config.skipSubFolders) {
      this.outputSectionSeparator("Sub-graphs");

      const subClusters = root.nodes.filter(
        node => node instanceof GraphCluster
      ) as GraphCluster[];

      subClusters.map(cluster => this.outputCluster(cluster));
    } else {
      this.outputter.outputLine(``);
    }

    this.outputSectionSeparator("Edges");
    this.outputEdges(root);
    this.outputter.outputLine(``);

    this.outputFooter();
  }

  private outputHeader() {
    this.outputter.outputLine(
      `/* auto-generated by tslint-folders docs tool at ${DateHelper.nowHumanReadable()}*/`
    );

    this.outputter.outputLine("digraph packages {");
    this.outputter.increaseIndent();

    this.outputGraphSettings();
  }

  private outputGraphSettings() {
    this.outputSectionSeparator("Graph settings");
    this.outputter.outputLine(`graph [`);
    this.outputter.increaseIndent();

    this.outputter.outputLines([
      `label = "${this.config.dot.title}"`,
      `labelloc = t`,
      ``,
      `//dpi = 200`,
      `ranksep=0.65`,
      `nodesep=0.40`,
      `rankdir=BT`,
      ``,
      `style="filled"`,
      ``,
      `len=0`
    ]);

    this.outputter.decreaseIndent();
    this.outputter.outputLine(`]`);
  }

  private outputFooter() {
    this.outputter.decreaseIndent();
    this.outputter.outputLine("}");
  }

  private outputSectionSeparator(sectionName: string) {
    this.outputter.outputLine(
      `/* ${sectionName} ================================= */`
    );
  }

  private outputTopLevelNodes(nodes: GraphNode[]) {
    this.outputTopLevelSubGraphBegin();

    nodes.forEach(node => {
      this.outputGraphNode(node);
    });

    this.outputTopLevelSubGraphEnd();
  }

  private outputTopLevelSubGraphBegin() {
    this.outputter.outputLine(`subgraph cluster_topLevel {`);
    this.outputter.increaseIndent();

    this.outputter.outputLine(`label = "${this.config.dot.subTitle}"`);

    this.styler.outputPlaceLabelsAtTop();

    this.styler.outputTopLevelSubGraphStyle();
  }

  private outputTopLevelSubGraphEnd() {
    this.outputter.decreaseIndent();
    this.outputter.outputLine("}");
  }

  private outputGraphNode(node: GraphNode) {
    this.outputScopeBegin();

    if (node.isExternal) {
      this.styler.outputStylingForExternalNode();
    }

    this.outputNode(node.name, node.description);

    this.outputScopeEnd();

    this.outputter.outputLine("");
  }

  private outputScopeBegin() {
    this.outputter.outputLine("{");
  }

  private outputScopeEnd() {
    this.outputter.outputLine("}");
  }

  /**
   * Output the separate graph cluster.
   */
  private outputCluster(cluster: GraphCluster) {
    const isContainer = cluster.nodes.length > 0;
    if (!isContainer) {
      return;
    }

    this.outputContainerNodeStart(cluster.name, cluster.description);

    this.outputSubNodes(cluster);

    this.outputContainerNodeEnd();
    this.outputter.outputLine(``);
  }

  private outputContainerNodeStart(name: string, description: string) {
    this.outputter.outputLine(`subgraph cluster_${this.containerId} {`);
    this.outputter.increaseIndent();

    this.styler.outputSubFolderStyle();

    const formattedDescription =
      description.length > 0 ? ` - ${description}` : "";

    this.outputter.outputLine(`label = "${name}${formattedDescription}"`);

    this.containerId++;
  }

  private outputContainerNodeEnd() {
    // styling at END so is not broken by contained node styling

    this.outputter.decreaseIndent();

    this.outputter.outputLine("}");
  }

  private outputNode(
    packageName: string,
    description: string,
    prefix?: string
  ) {
    const packageIdKey = this.getPackageIdKey(packageName, prefix);

    const packageId = this.mapNameToId.getId(packageIdKey);

    const fillColor = this.getColorNumber(packageIdKey);

    this.outputter.outputLine(
      `${packageId} [label="${packageName}\n${description}" fillcolor=${fillColor}]`
    );
  }

  private getColorNumber(packageIdKey: string): number {
    let packageNumber = this.mapNameToId.getNumberOrThrow(packageIdKey);

    if (packageNumber > this.config.dot.maxColors) {
      packageNumber = packageNumber % this.config.dot.maxColors;
    }

    if (packageNumber === 0) {
      // for a graphviz color scheme, the color number must be 1 based:
      packageNumber = 1;
    }

    return packageNumber;
  }

  private getPackageIdKey(packageName: string, prefix?: string): string {
    return `${prefix}_${packageName}`;
  }

  private outputEdges(root: GraphCluster) {
    const walker = new GraphVisitor(root);
    walker.visitEdges(edge => this.outputEdge(edge));
  }

  private outputEdge(edge: Edge) {
    this.outputter.outputLine(
      // reversing, so that 'top-level' nodes appear at top:
      `${edge.destination.id}-> ${edge.origin.id} [dir="back"]`
    );
  }

  private outputSubNodes(cluster: GraphCluster) {
    if (cluster.nodes.length === 0) {
      this.outputter.outputLine("");
      return;
    }

    cluster.nodes.forEach(node => {
      this.outputNode(node.name, node.description, cluster.name);

      this.outputter.outputLine("");
    });
  }
}
